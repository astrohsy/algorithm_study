# 3부 알고리즘 설계 패러다임
### 개관

- 알고리즘을 고안하는 작업은 어려운 일입니다.
- 그러나 고수들도 한순간의 영감으로 문제를 해결하지 않으며, 여러가지의 전략적인 선택을 하게 됩니다.
- 알고리즘 설계 패러다임이란 알고리즘에 사용된 전략이나 관점을 의마합니다.
- 3부(6장~12장)에서 다양한 알고리즘 설계 패러다임을 익히면서 일종의 패턴을 확인할 수 있으며 이를 통해 알고리즘 설계 능력이 향상될 것입니다.
- 알고리즘 설계 패턴 : 무식하게 풀기, 분할정복, 동적 계획법, 탐욕법, 조합 탐색, 최적화 문제

# 6장. 무식하게 풀기
## 6.1 도입

* 프로그래밍 대회에서 가장 많이 하는 실수는 문제를 어렵게 풀려고 하는 것입니다.
* 먼저, 스스로에게 물어봅시다. "무식하게 풀 수 있을까?"
* 그럼 무식하게 풀기(brute-force)란 무엇일까요?
  * 주어진 문제에서 가능한 **모든 경우의 수**를 무식하게 다 해보는 것입니다.  
    ※ 컴퓨터의 장점인 빠른 속도를 이용합시다!
  * 예1) A-B까지의 최단경로를 찾는 문제 --> 가능한 경로를 모두 찾아서 서로 비교
  * 예2) 자원을 몇명에게 분배하는 문제 --> 분배할 수 있는 모든 경우의 수를 찾아서 비교
* 이렇게 모든 경우의 수를 다 구하는 방법을 **완전탐색**(exhaustive search)이라고도 합니다.
* 예제
  * 10명의 학생을 한 줄로 세우려고 합니다.
  * 그런데 서로 사이가 안 좋은 학생들이 있어서 붙여놓면 싸웁니다.
  * 그래서 사이가 안 좋은 학생들은 떨어뜨리는 방법이 몇 개인지 찾고 싶습니다.
  * 해결방법
    * 마땅한 해결방법이 떠오르지 않습니다.
    * 네, 무식하게 풀기를 사용해 봅시다.
    * 10명을 한 줄로 세우는 모든 방법을 다 구합니다.  
      ※ 10! = 3,628,800
    * 그 후에 사이가 안 좋은 학생들이 붙어 있는지 검사해주는 함수를 사용합니다.
* 이런 방법이 의미가 있을까요?
  * 4장에서 배운 주먹구구 법칙에서 1초에 수행해야 할 연산이 1억개 미만이면 성공가능성이 있었습니다.
  * 따라서 360만이면 많게 보이지만 프로그램의 시간복잡도가 높지 않으면 충분히 해볼만한 개수입니다.
* 무식하게 풀기(완전탐색)의 구현방법은 어떻게 될까요? 반복문 또는 재귀호출을 사용하면 됩니다.

## 6.2 재귀호출과 완전 탐색 

### 재귀호출

* 반복문과 재귀함수의 목적은 **"반복한다"**라는 관점에서 동일합니다.
* 항상 그런것은 아니지만, 완전 탐색을 구현할 때는 재귀함수가 반복문보다 더 유용합니다.
* 아래 예제에서 반복문을 재귀함수로 변경하는 방법에 대해서 알아보겠습니다.
* 예제
  * 입력 : 자연수 n
  * 출력 : 1~n 까지의 합을 반환
  * 해결방법 : 반복문과 재귀함수로 각각 구현
    ```c++
    // 필수 조건 : n >=1
    // 결과 : 1부터 n까지의 합을 반환한다
    int sum(int n) {
        int ret = 0;
        for(int i=1; i<=n; ++i)
            ret += i;
        return ret;
    }
    
    // 필수 조건 : n >= 1
    // 결과 : 1부터 n까지의 합을 반환한다
    int recursiveSum(int n) {
        if(n == 1) 
            return 1;
        return n + recursiveSum(n-1);
    }
    ```
* 위의 반복문과 재귀함수는 동일한 결과를 계산해줍니다.
* 재귀함수를 구성하는 기본적인 구성요소는 아래 3가지입니다.
  * 조각 : 어떤 문제를 쪼개서 유사한 동작을 하는 단위를 찾기 (반복수행해야 할 대상)
  * 조각마다 반복하기 : 1개의 조각을 수행하고 남은 조각들은 다시 자기자신을 호출해서 수행
  * 기저사례(base case) : 제일 마지막 조각을 확인해서 무한히 호출되는 것을 막기
* 위의 int recursiveSum(int n) 함수에서 재귀함수의 구성요소 3가지를 찾아보면 아래와 같습니다.
  * 조각 : 1, 2, 3, ...., n-1, n 과 같은 각각의 숫자입니다.
  * 조각마다 반복하기 : 조각 중 하나를 수행하고 나머지는 다시 자기자신에게 전달해서 수행하도록 합니다. 반복수행의 모습은 n + (n-1 + ... + 1) 입니다. 그래야 다음 호출에서도 처음과 똑같은 모습 n -1 (n-2 + ... +  1) 을 유지할 수 있습니다. 
  * 기저사례(base case) : n 부터 하나씩 빼가면서 자신을 호출했을 때, **1** 까지 도달하면 더 이상 진행할 필요가 없음을 알 수 있습니다. 따라서 **1**이 곧 기저사례입니다.
* 그럼 완전탐색에서 반복문보다 재귀함수를 좋은 이유가 뭘까요? 아래 예제에서 확인할 수 있습니다.
* 예제: 중첩 반복문 대체하기
  * 0~n 중에서 4개를 고르는 모든 경우를 출력하기 입니다. (순서에 상관없이)
  * 만약, n=7 이라면 아래와 같이 출력돼야 합니다.
    * (0,1,2,3), (0,1,2,4), (0,1,2,5), ... , (3,4,5,6)
    * 7C4 = n! / r!(n-r)! = 7! / 4!3! = 35가지
  * 해결방법 : 반복문
    ```c++
    for (int i=0; i < n; ++i)
        for (int j=i+1; j < n; ++j)
            for (int k=j+1; k < n; ++k)
                for (int l=k+1; l < n; ++l)
                    cout << i << " " << j << " " << k << " " << l << endl;
    ```
    * 4개를 고를 땐 반복문 4개가 중첩됩니다.
    * 5개를 골라야 한다면? 반복문 5개가 중첩되야 하며 숫자가 늘어날수록 반복문의 중첩도 깊어질 것입니다.  
      : 코드의 복잡도 증가
    * 더 큰 단점은 골라야 할 개수가 코드상에서 정해져있다는 것입니다. (개수에 따라 반복문을 추가해야 합니다.)  
      : 유연성 부족
    * 이처럼 완전탐색 알고리즘을 구현할 때, 반복문을 사용하면 코드의 복잡도가 올라가고 유연성이 떨어지는 문제가 있습니다.
  * 해결방법 : 재귀함수
    ```c++
    // n : 원소들의 총 개수
    // picked : 지금까지 고른 원소들의 번호
    // toPick : 더 골라야 할 원소들의 개수
    void pick(int n, vector<int>& picked, int toPick) {
        // 기저사례 : 더 고를 원소가 없을 때, 원소들을 출력한다
        if (toPick == 0) {
            printPicked(picked); 
            return;
        }
        
        // 고를 수 있는 가장 작은 번호를 계산한다
        int smallest = picked.empty() ? 0 : picked.back() + 1;
        
        // 이 단계에서 원소 하나를 고른다
        for(int next = smallest; next < n; ++next) {
            picked.push_back(next);
            pick(n, picked, toPick-1);
            picked.pop_back();
        }
    }
    ```
    * 조각 : 4개를 골라야 한다면 그 중 하나를 고르는 것
  * 조각마다 반복하기 : 1개만 고르고 나머지 고르는 과정을 다음으로 넘김
    * 기저사례(base case) : 4개를 다 골랐을 때
    * 
    * 우선 위의 반복문을 보면 for문 1개당 하나의 원소를 고른다
    * 재귀함수는 1개 함수이므로 주업무를 어떤것으로 할지 잘 골라야 한다
      - 이 때는 문제를 **조각** 낸 후에 가장 중요한 동작을 재귀함수의 주요 동작으로 선택한다
      - **조각**을 기억하자
    * 또한, 재귀함수가 필요로하는 파라미터를 정의할 수 있어야 한다
      - 원소들의 총 개수
      - 지금까지 고른 원소들의 번호
      - 더 골라야 할 원소들의 개수
    * 위의 소스코드는 반복문이 하나만 사용됐다
    * 재귀함수를 쉽게 이해하기 위한 그림을 보면 아래와 같다
    ![](https://github.com/ant35rookie/share/blob/master/docs/ch6/22.jpg)
      * 가정 : n = 4 일 때, 3개를 고르기 (4C3 = 4! / 3!1! 이므로 결과는 총 4개가 나와야 한다)
  
* 예제: 보글 게임 (난이도 : 하)
  * 문제
    * 5x5 크기의 알파벳 격자를 가지고 하는 게임
    * **상하좌우 및 대각선**으로 인전합 칸들의 글자를 이어서 단어를 찾아내는 게임
    * 예를 들어 아래 그림 b, c, d  의 답은 각각 PRETTY, GIRL, REPEAT 이다
    * 아래 그림에서 a, e 와 같은 격자와 찾고자 하는 단어가 주이지면, 해당 단어가 있는지 검사하는 함수 구현
    * 시작점은 주어짐
    ![](https://github.com/ant35rookie/share/blob/master/docs/ch6/11.jpg)
  * 생각해볼 점
    * 위 그림 e 는 YES 라는 단어를 찾는 것이다
    * 시작점이 정가운데 Y 라고 하면, 가능한 E가 모든 방향으로 8개나 된다
    * 정답은 우측 상단 대각선인데, 이것을 어떻게 하면 알 수 있을까?
  > 여기서도 무식하게 풀어보는 것이다, 즉 모든 경우의 수를 다 해본다
  * 문제의 분할
    * 조각을 내보자
      * 각 칸과 현재 찾고 있는 음절을 비교하는 것을 하나의 조각으로 보면 자연스럽다
    * 재귀함수이 이름과 필요한 파라미터는 아래와 같이 정의할 수 있다
      * hasWord(y, x, word)
    * 파라미터는 y,x 는 시작점, word는 찾는 단어
  * 기저 사례 고르기
    * 먼저, 추가진행할 필요가 없이 결정되는 사항들을 찾고 예외처리 해야한다
      1. 위치 (y,x)에 있는 글자가 원하는 단어의 첫 글자가 아닌 경우 항상 실패
      2. (1번이 아니고) 원하는 단어가 1글자일 때 항상 성공
    * 더불어서 입력이 잘못된 경우를 찾고 예외처리 해야한다
      1. 범위오류
       (이런 기본적인 얼토당토 않은 기저사례를 찾았다면 코딩할 때 기저사례 중에서도 윗부분에 적어주는게 좋다)
  
* 구현
    ```c++
    const int dx[8] = {-1, -1, -1,  1, 1, 1,  0, 0};
    const int dy[8] = {-1,  0,  1, -1, 0, 1, -1, 1};
    
    // 5x5의 보글게임판에서 주어진 단어가 있는지를 확인하는 함수
    bool hasWord(int y, int x, const string& word) {
    	// 기저사례 1: 시작 위치가 범위 밖이면 무조건 실패
    	if(!inRange(y, x))
    		return false;
        
    	// 기저사례 2: 첫 글자가 일치하지 않으면 실패
    	if(board[y][x] != word[0])
    		return false;
    		
    	// 기저사례 3: 단어 길이가 1이면 성공
    	if(word.size() == 1) return true;
    	
    	// 인접한 여덟 칸을 검사한다
    	for(int direction=0; direction <8; ++direction) {
    		int nextY = y + dy[direction], nextX = x + dx[direction];
    		
    		// 다음 칸이 범위 안에 있는지, 첫 글자는 일치하는지 확인할 필요가 없다
    		if(hasWord(nextY, nextX, word.substr(1)))
    			return true;
    	}
    	return false;
    }
  ```
    * 위의 재귀함수를 쉽게 이해하려면
      * 문제의 정의가 boolean 을 최종적으로 return 하는 것이 목적임을 정확히 파악하고 있어야 하며
      * 그래서 가능한 경우를 하나라도 찾으면 true 가 연쇄적으로 일어나서 최종 return 하는 구현이다
    * 바로 다음글자 8개중에 true가 없으면 현재 글자도 false를 return하고 있다
  
* 시간복잡도 분석
    * 사실, 완전탐색의 경우 모든 경우의 수를 무식하게 푸는 것이므로 대개의 경우에 시간복잡도 계산도 단순하다
    * 그렇긴 하지만, 보글 게임에서 사용한 알고리즘은 해답을 찾으면 바로 리턴하기 때문에 까다로움이 더해진다
    * 일단, 최악의 경우만 고려해보자
      * 8x8 격자에서 답이 없었다고 한다면, 모든 경우의 수가 곧 시간복잡도가 된다
      * 단어의 길이수 마다 8개의 재귀함수를 호출한다 (8개 방향)
      * 마지막 글자는 기저사례 3 에 의해 제외되므로, 시간복잡도는 8^n-1 = O(8^n) 이 된다
    * 8^n 은 지수복잡도이다
    * 지금은 데이터량이 작지만, 지수복잡도는 데이터가 조금만 커져도 문제가 될 것이다
    * 이렇듯 무식하게 풀기는 데이터량 (여기서는 단어길이) 에 따라 실패할 수도 있다
  * 8장에서는 배우는 동적계획법을 통해 이를 개선해보자
  
* 완전탐색 레시피
    * 완전 탐색으로 문제를 해결하는 과정
    * 모든 경우에 적용되는 것은 아니지만, 대략적인 지침으로 기억하면 좋음
      1. 완전 탐색은 존재하는 모든 답을 검사하므로 걸리는 시간은 측정이 용이한 측면이 있다
         따라서 완전 탐색 or 무식하게 풀기 or brute-force 로 주어진 문제를 풀 수 있을지 빠르게 판단하자
         만약, 불가능하다면 또다른 알고리즘 전략을 채택해야 한다
      2. 완전 탐색을 수행하는 과정을 여러개의 조각으로 나누자
      3. 그 중 하나의 조각을 선택해 완전 탐색의 일부를 만들고, 완전탐색의 나머지는 재귀 호출을 통해 완성한다 (이전에 나온 4중 for 문에서 1개만 재귀함수에서 수행하고, 나머지는 재귀호출을 했다)
      4. 더 이상 진행할 수 없는 경우를 파악하여 기저 사례를 꼭 처리하자
    
* 이론적 배경: 재귀 호출과 부분 문제
  * 재귀 호출을 공부하면서 짚고 넘어가야할 개념
    * 문제와 부분문제 (problem & subproblem)
  * 위 개념은 다음에 배울 동적계획법이나 분할정복에서도 사용되므로 중요하다
  * 일단, 문제의 정의란 무엇인가 생각해보자
    * 아래 2개 문제를 봐보자
      * 문제 #1 : 주어진 자연수 수열을 정렬하라
      * 문제 #2 : {16, 7, 9, 1, 31} 을 정렬하라
    * 얼핏 보면 비슷하지만, 큰 차이가 있다
      * 재귀함수에서는 자료의 조합이 정말 중요하다
        심지어 {1,2,3} 을 정렬하는 것과 {3,2,1}을 정렬하는 문제도 서로 다르다
      * 따라서, 위의 문제 2개는 엄밀히 다른 문제이고, 전자는 범위가 없으므로 문제의 정의라고 보기도 어렵다
  * 이제, 문제와 부분문제의 차이점을 통해 이해하고 조각도 찾아볼 수 있다
    * 보글게임의 완전탐색 과정 (즉, **조각**) 을 보면 아래와 같다
      1. 현재 위치 (y, x) 에서 단어의 첫 글자가 있는가?
      2. 상단 (y-1, x) 에서 시작해서, 단어의 나머지 글자들을 찾을 수 있는가?
      3. 좌상단 (y-1, x-1) 에서 시작해서, 단어의 나머지 글자들을 찾을 수 있는가?
      4. ...
      5. ...
    * 최종적으로 총 9개의 **조각**이 나오겠지만 사실 2~9번은 1번으로 부터 파생된 것이다
    * 이 때, 1번은 문제라고 하고, 2~9 은 부분문제가 된다 

## 6.3 문제: 소풍 (난이도: 하)

* 문제
  * 유치원에서 소풍감
  * 선생님은 2명씩 짝을 지어주려 함
  * 친구가 아닌 아이들을 짝지어주면 싸워서 안됨
  * 일부만 달라도 다른 방법이라고 봄, 따라서 아래 2가지는 다른 방법임
    * #1 - (태연, 제시카), (써니, 티파니), (효연, 유리)
    * #2 - (태연, 제시카), (써니, 유리), (효연, 티파니)
* 시간 & 메모리 제한
  
  * 1초 내 실행, 64MB 이하의 메모리
* 입력
  * 첫 줄에는 테스트 케이스의 수 C (C<=50)
  * 각 테스트 케이스
    * 첫번째 줄 : 학생의 수 n (2 <= n <= 10) , 친구 쌍의 수 m (0 <= m <= n(n-1) / 2)
    * 두번째 줄 : 친구 쌍 
* 출력
  
  * 각 테스트 케이스마다 모든 학생을 친구끼리만 짝지어줄 수 있는 방법의 수를 출력
* 예제 입력

  ```shell
  3
  2 1
  0 1
  4 6
  0 1 1 2 2 3 3 0 0 2 1 3
  6 10
  0 1 0 2 1 2 1 3 1 4 2 3 2 4 3 4 3 5 4 5
  ```
* 예제 출력
  ```shell
  1
  3
  4
  ```
* 예제 입출력 설명
  * 첫 번째 테스트케이스
    * (2 1)은 학생이 2명이고 짝이 1개 이므로 답도 1개
  * 두 번째 테스트케이스
    * (4 6)은 학생이 4명이고 6개 짝이므로 모두 친구라는 의미가 됨 (4C2 = 총 6개)
    * 4명을 A,B,C,D라고 할 때, 최종적으로 아래와 같은 3가지 방법이 가능함을 알 수 있다
      * (A, B) (C, D)
      * (B, D) (A, C)
      * (C, A) (A, D)

## 6.4 풀이: 소풍

* 완전 탐색
  * 역시 완전 탐색이 어울리는 문제이며 재귀 호출을 이용해 코드를 작성해 보자
  * 조각 정하기
    * 2명씩 짝을 짓는 문제이니 전체 학생 n에 대해 n/2 개의 조각이 있다고 하자
    * 그리고 한 조각에서는 2명을 짝지어주는 것을 목표로 하자
    * 그럼 재귀함수는 주어진 학생들 중에서 계속해서 2명을 짝지어주는 것이 된다
* 1차 코드 (코드 6.4))
  ```c++
  // 전체 학생의 수
  int n;
  // 친구배열
  //   0 1 2 3 ... 
  // 0 x o x o
  // 1 o x x x
  // 2 x x x o
  bool areFriends[10][10];
  
  // taken[i] = i번째 학생이 짝을 이미 찾았으면 true, 아니면 false
  int countParings(bool taken[10]) {
  	// 기저사례: 모든 학생이 짝을 찾았으면 가능한 1가지 경우를 찾았다고 상위에 알려준다
  	// taken[i] 가 모두 true 이므로 짝이 없는 친구가 없는 것임
  	bool finished = true;
  	for(int i =0; i<n; ++i)
  		if(!taken[i]) finished = false;
      if(finished)
      	return 1;
    
      // ret 에 주목해보자
      // 이 함수는 가능한 경우의 수를 모두 찾는 것이다, 따라서 ret을 계속 더해가는 구조이다
      // 만약 친구들을 모두 검색했는데, 그런 경우를 못 찾으면 ret=0 을 반환하므로
      // 해당 경우는 짝지을 수 있는 방법이 없는 것이다, 즉 집계되지 않는다
  	int ret=0;
      // 서로 친구인 두 학생을 찾아 짝을 지어 준다
      for(int i=0; i<n; ++i) {
          for(int j=0; j<n; ++j) {
              // i, j 가 친구가 없는데, 둘이 친구이면
              if(!taken[i] && !taken[j] && areFriends[i][j]) {
                  taken[i] = taken[j] = true;
                  ret += countPairings(taken);
                  taken[i] = taken[j] = false;
              }
          }
      }
      return ret;
  }
  ```
  * 소스코드 이해하기 (그림)
  ![](https://github.com/ant35rookie/share/blob/master/docs/ch6/33.jpg)
  * 근데 실행해보면, 답이 1 3 4 로 나오지 않음
  * 위 코드의 문제점?
    * 중복으로 세는 것이 발생
    * (0 1) 과 (1 0) 을 별개로 취급함
    * 이러한 문제는 매우 자주 발생하기 때문에 유의해야 함
  * 해결법
    * 빠른 번호부터 찾는 것으로 순서를 강제함
    * 다음에는 남아있는 학생들중에서 번호가 빠른 아이를 또 찾아 주도록 함
    * 그러면 (0 1) 은 찾게 되지만, (1 0) 과 같은 역순은 발생할 수 없음
* 2차 코드 (코드 6.5)
  ```c++
  int n;
  bool areFriends[10][10];
  
  // taken[i] = i번째 학생이 짝을 이미 찾았으면 true, 아니면 false
  int countParings(bool taken[10]) {
      // 남은 학생들 중 가장 번호가 빠른 학생을 찾는다
      int firstFree = -1;
      for(int i=0; i <n ++i) {
          if(!taken[i]) {
              firstFree = i;
              break;
          }
      }
      
      // 기저사례: 모든 학생이 짝을 찾았으면 가능한 1가지 경우를 찾았다고 상위에 알려준다
      // taken[i] 가 모두 true 이므로 짝이 없는 친구가 없는 것임
      if(firstFree == -1)
          return 1;
      
      int ret = 0;
      // 이 학생과 짝지을 학생을 결정한다
      // firstFree + 1 이 핵심이며 바로 다음순서 학생부터 검색시작함을 의미한다
      for(int pairWith = firstFree+1; pairWith <n; ++pariWith) {
          if(!taken[pairWith] && areFriends[firstFree][pairWith]) {
              taken[firstFree] = taken[pairWith] = true;
              ret += countPairings(taken);
              taken[firstFree] = taken[pairWith] = false;
          }
      }
      return ret;
  }
  ```
  * 소스코드 이해하기 (그림)
  ![](https://github.com/ant35rookie/share/blob/master/docs/ch6/44.jpg)
  * 위 코드에서 답으로 가능한 최대개수
    * 학생 수 10명이 서로 모두 친구인 경우
    * 9 x 7 x 5 x 3 x 1 = 945
      * 첫번째 학생은 9개의 선택지 - 2명 짝지어짐
      * 세번째 학생은 7개의 선택지 - 4명 짝지어짐
      * ...
* 재귀함수를 구현하고자 할 때, 3가지를 잘 생각해보자
  * 조각으로 할 것
  * 반환할 것 (boolean 인지?  int 인지?)
  * 함수간에 공유할 것 (파라미터)
