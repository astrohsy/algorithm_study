# 3부 알고리즘 설계 패러다임
### 개관

- 알고리즘을 고안하는 작업은 어려운 일입니다.
- 그러나 고수들도 한순간의 영감으로 문제를 해결하지 않으며, 여러가지의 전략적인 선택을 하게 됩니다.
- 알고리즘 설계 패러다임이란 알고리즘에 사용된 전략이나 관점을 의마합니다.
- 3부(6장~12장)에서 다양한 알고리즘 설계 패러다임을 익히면서 일종의 패턴을 확인할 수 있으며 이를 통해 알고리즘 설계 능력이 향상될 것입니다.
- 알고리즘 설계 패턴 : 무식하게 풀기, 분할정복, 동적 계획법, 탐욕법, 조합 탐색, 최적화 문제

# 6장. 무식하게 풀기
## 6.1 도입

* 프로그래밍 대회에서 가장 많이 하는 실수는 문제를 어렵게 풀려고 하는 것입니다.
* 먼저, 스스로에게 물어봅시다. "무식하게 풀 수 있을까?"
* 그럼 무식하게 풀기(brute-force)란 무엇일까요?
  * 주어진 문제에서 가능한 **모든 경우의 수**를 무식하게 다 해보는 것입니다.  
    ※ 컴퓨터의 장점인 빠른 속도를 이용합시다!
  * 예1) A-B까지의 최단경로를 찾는 문제 --> 가능한 경로를 모두 찾아서 서로 비교
  * 예2) 자원을 몇명에게 분배하는 문제 --> 분배할 수 있는 모든 경우의 수를 찾아서 비교
* 이렇게 모든 경우의 수를 다 구하는 방법을 **완전탐색**(exhaustive search)이라고도 합니다.
* 예제
  * 10명의 학생을 한 줄로 세우려고 합니다.
  * 그런데 서로 사이가 안 좋은 학생들이 있어서 붙여놓면 싸웁니다.
  * 그래서 사이가 안 좋은 학생들은 떨어뜨리는 방법이 몇 개인지 찾고 싶습니다.
  * 해결방법
    * 마땅한 해결방법이 떠오르지 않습니다.
    * 네, 무식하게 풀기를 사용해 봅시다.
    * 10명을 한 줄로 세우는 모든 방법을 다 구합니다.  
      ※ 10! = 3,628,800
    * 그 후에 사이가 안 좋은 학생들이 붙어 있는지 검사해주는 함수를 사용합니다.
* 이런 방법이 의미가 있을까요?
  * 4장에서 배운 주먹구구 법칙에서 1초에 수행해야 할 연산이 1억개 미만이면 성공가능성이 있었습니다.
  * 따라서 360만이면 많게 보이지만 프로그램의 시간복잡도가 높지 않으면 충분히 해볼만한 개수입니다.
* 무식하게 풀기(완전탐색)의 구현방법은 어떻게 될까요? 반복문 또는 재귀호출을 사용하면 됩니다.

## 6.2 재귀호출과 완전 탐색 

### 재귀호출

* 반복문과 재귀함수의 목적은 **"반복한다"**라는 관점에서 동일합니다.
* 항상 그런것은 아니지만, 완전 탐색을 구현할 때는 재귀함수가 반복문보다 더 유용합니다.
* 아래 예제에서 반복문을 재귀함수로 변경하는 방법에 대해서 알아보겠습니다.
* 예제
  * 입력 : 자연수 n
  * 출력 : 1~n 까지의 합을 반환
  * 해결방법 : 반복문과 재귀함수로 각각 구현
    ```c++
    // 필수 조건 : n >=1
    // 결과 : 1부터 n까지의 합을 반환한다
    int sum(int n) {
        int ret = 0;
        for(int i=1; i<=n; ++i)
            ret += i;
        return ret;
    }
    
    // 필수 조건 : n >= 1
    // 결과 : 1부터 n까지의 합을 반환한다
    int recursiveSum(int n) {
        if(n == 1) 
            return 1;
        return n + recursiveSum(n-1);
    }
    ```
* 위의 반복문과 재귀함수는 동일한 결과를 계산해줍니다.
* 재귀함수를 구성하는 기본적인 구성요소는 아래 3가지입니다.
  * 조각 : 어떤 문제를 쪼개서 유사한 동작을 하는 단위를 찾기 (반복수행해야 할 대상)
  * 조각마다 반복하기 : 1개의 조각을 수행하고 남은 조각들은 다시 자기자신을 호출해서 수행
  * 기저사례(base case) : 제일 마지막 조각을 확인해서 무한히 호출되는 것을 막기
* 위의 int recursiveSum(int n) 함수에서 재귀함수의 구성요소 3가지를 찾아보면 아래와 같습니다.
  * 조각 : 1, 2, 3, ...., n-1, n 과 같은 각각의 숫자입니다.
  * 조각마다 반복하기 : 조각 중 하나를 수행하고 나머지는 다시 자기자신에게 전달해서 수행하도록 합니다. 반복수행의 모습은 n + (n-1 + ... + 1) 입니다. 그래야 다음 호출에서도 처음과 똑같은 모습 n -1 (n-2 + ... +  1) 을 유지할 수 있습니다. 
  * 기저사례(base case) : n 부터 하나씩 빼가면서 자신을 호출했을 때, **1** 까지 도달하면 더 이상 진행할 필요가 없음을 알 수 있습니다. 따라서 **1**이 곧 기저사례입니다.
* 그럼 완전탐색에서 반복문보다 재귀함수를 좋은 이유가 뭘까요? 아래 예제에서 확인할 수 있습니다.
* 예제: 중첩 반복문 대체하기
  * 0~n 중에서 4개를 고르는 모든 경우를 출력하기 입니다. (순서에 상관없이)
  * 만약, n=7 이라면 아래와 같이 출력돼야 합니다.
    * (0,1,2,3), (0,1,2,4), (0,1,2,5), ... , (3,4,5,6)
    * 7C4 = n! / r!(n-r)! = 7! / 4!3! = 35가지
  * 해결방법 : 반복문
    ```c++
    for (int i=0; i < n; ++i)
        for (int j=i+1; j < n; ++j)
            for (int k=j+1; k < n; ++k)
                for (int l=k+1; l < n; ++l)
                    cout << i << " " << j << " " << k << " " << l << endl;
    ```
    * 4개를 고를 땐 반복문 4개가 중첩됩니다.
    * 5개를 골라야 한다면? 반복문 5개가 중첩되야 하며 숫자가 늘어날수록 반복문의 중첩도 깊어질 것입니다.  
      : 코드의 복잡도 증가
    * 더 큰 단점은 골라야 할 개수가 코드상에서 정해져있다는 것입니다. (개수에 따라 반복문을 추가해야 합니다.)  
      : 유연성 부족
    * 이처럼 완전탐색 알고리즘을 구현할 때, 반복문을 사용하면 코드의 복잡도가 올라가고 유연성이 떨어지는 문제가 있습니다.
  * 해결방법 : 재귀함수
    ```c++
    // n : 원소들의 총 개수
    // picked : 지금까지 고른 원소들의 번호
    // toPick : 더 골라야 할 원소들의 개수
    void pick(int n, vector<int>& picked, int toPick) {
        // 기저사례 : 더 고를 원소가 없을 때, 원소들을 출력한다
        if (toPick == 0) {
            printPicked(picked); 
            return;
        }
        
        // 고를 수 있는 가장 작은 번호를 계산한다
        int smallest = picked.empty() ? 0 : picked.back() + 1;
        
        // 이 단계에서 원소 하나를 고른다
        for(int next = smallest; next < n; ++next) {
            picked.push_back(next);
            pick(n, picked, toPick-1);
            picked.pop_back();
        }
    }
    ```
    * 조각 : 4개를 골라야 한다면 그 중 하나를 고르는 것
    
    * 조각마다 반복하기 : 1개만 고르고 나머지 고르는 과정을 다음으로 넘김
    
    * 기저사례(base case) : 4개를 다 골랐을 때
      
    * 우선 위의 반복문을 보면 for문 1개당 하나의 원소를 고릅니다.
    
    * 재귀함수는 1개 함수이므로 주업무를 어떤것으로 할지 잘 골라야 합니다.
      - 이 때는 문제를 **조각** 낸 후에 가장 중요한 동작을 재귀함수의 주요 동작으로 선택합니다.
      - **조각**을 기억해야 합니다.
      
    * 또한, 재귀함수가 필요로하는 파라미터를 정의할 수 있어야 합니다.
      - 원소들의 총 개수
      - 지금까지 고른 원소들의 번호
      - 더 골라야 할 원소들의 개수
      
    * 위의 소스코드는 반복문이 하나만 사용됐습니다.
    
    * 재귀함수를 쉽게 이해하기 위한 그림을 보면 아래와 같습니다.  
    
      ![](images/1.jpg)
      
      * 가정 : n = 4 일 때, 3개를 고르기 (4C3 = 4! / 3!1! 이므로 결과는 총 4개가 나와야 한다)
  
* 예제: 보글 게임 (난이도 : 하)
  * 문제
    * 5x5 크기의 알파벳 격자를 가지고 하는 게임
    * **상하좌우 및 대각선**으로 인전합 칸들의 글자를 이어서 단어를 찾아내는 게임
    * 예를 들어 아래 그림 b, c, d  의 답은 각각 PRETTY, GIRL, REPEAT 이다
    * 아래 그림에서 a, e 와 같은 격자와 찾고자 하는 단어가 주이지면, 해당 단어가 있는지 검사하는 함수 구현
    * 시작점은 주어짐
    ![](images/2-1.jpg)
  * 생각해볼 점
    * 위 그림 e 는 YES 라는 단어를 찾는 것입니다.
    * 시작점이 정가운데 Y 라고 하면, 가능한 E가 모든 방향으로 8개나 됩니다.
    * 정답은 우측 상단 대각선인데, 이것을 어떻게 하면 알 수 있을까요?
    * 여기서도 무식하게 풀어보는 것이다, 즉 모든 경우의 수를 다 해봅니다.
  * 문제의 분할
    * 조각을 내보자
      * 각 칸과 현재 찾고 있는 음절을 비교하는 것을 하나의 조각으로 보면 자연스럽습니다.
    * 재귀함수이 이름과 필요한 파라미터는 아래와 같이 정의할 수 있습니다.
      * hasWord(y, x, word)
    * 파라미터는 y,x 는 시작점, word는 찾는 단어
  * 기저 사례 고르기
    * 먼저, 추가진행할 필요가 없이 결정되는 사항들을 찾고 예외처리 해야합니다.
      1. 위치 (y,x)에 있는 글자가 원하는 단어의 첫 글자가 아닌 경우 항상 실패
      2. (1번이 아니고) 원하는 단어가 1글자일 때 항상 성공
    * 더불어서 입력이 잘못된 경우를 찾고 예외처리 해야합니다.
      1. 범위오류
       (이런 기본적인 얼토당토 않은 기저사례를 찾았다면 코딩할 때 기저사례 중에서도 윗부분에 적어주는게 좋습니다)
  
* 구현
    ```c++
    const int dx[8] = {-1, -1, -1,  1, 1, 1,  0, 0};
    const int dy[8] = {-1,  0,  1, -1, 0, 1, -1, 1};
    
    // 5x5의 보글게임판에서 주어진 단어가 있는지를 확인하는 함수
    bool hasWord(int y, int x, const string& word) {
    	// 기저사례 1: 시작 위치가 범위 밖이면 무조건 실패
    	if(!inRange(y, x))
    		return false;
        
    	// 기저사례 2: 첫 글자가 일치하지 않으면 실패
    	if(board[y][x] != word[0])
    		return false;
    		
    	// 기저사례 3: 단어 길이가 1이면 성공
    	if(word.size() == 1) return true;
    	
    	// 인접한 여덟 칸을 검사한다
    	for(int direction=0; direction <8; ++direction) {
    		int nextY = y + dy[direction], nextX = x + dx[direction];
    		
    		// 다음 칸이 범위 안에 있는지, 첫 글자는 일치하는지 확인할 필요가 없다
    		if(hasWord(nextY, nextX, word.substr(1)))
    			return true;
    	}
    	return false;
    }
  ```
    * 위의 재귀함수를 쉽게 이해하려면
      * 문제의 정의가 boolean 을 최종적으로 return 하는 것이 목적임을 정확히 파악하고 있어야 하며
      * 그래서 가능한 경우를 하나라도 찾으면 true 가 연쇄적으로 일어나서 최종 return 하는 구현입니다.
    * 바로 다음글자 8개중에 true가 없으면 현재 글자도 false를 return하고 있습니다.  
      ![](images/2-2.jpg)  
    ![](images/2-3.jpg)
  
* 시간복잡도 분석
    * 사실, 완전탐색의 경우 모든 경우의 수를 무식하게 푸는 것이므로 대개의 경우에 시간복잡도 계산도 단순합니다.
    * 그렇긴 하지만, 보글 게임에서 사용한 알고리즘은 해답을 찾으면 바로 리턴하기 때문에 까다로움이 더해집니다.
    * 최악의 경우
      * 8x8 격자에서 답이 없었다고 한다면, 모든 경우의 수가 곧 시간복잡도가 됩니다.
      * 단어의 길이수 마다 8개의 재귀함수를 호출한다 (8개 방향)
      * 마지막 글자는 기저사례 3 에 의해 제외되므로, 시간복잡도는 8^n-1 = O(8^n) 이 된다
    * 8^n 은 지수복잡도 알고리즘입니다.
    * 지금은 데이터량이 작지만, 지수복잡도는 데이터가 조금만 커져도 문제가 될 것입니다.
    * 이렇듯 무식하게 풀기는 데이터량 (여기서는 단어길이) 에 따라 실패할 수도 있습니다.
  * 8장에서는 배우는 동적계획법을 통해 이를 개선할 수 있습니다.
  
* 완전탐색 레시피
    * 완전 탐색으로 문제를 해결하는 과정
    * 모든 경우에 적용되는 것은 아니지만, 대략적인 지침으로 기억하면 좋습니다.
      1. 완전 탐색은 존재하는 모든 답을 검사하므로 걸리는 시간은 측정이 용이한 측면이 있습니다.
         따라서 완전 탐색 or 무식하게 풀기 or brute-force 로 주어진 문제를 풀 수 있을지 빠르게 판단해야 합니다.
         만약, 불가능하다면 또다른 알고리즘 전략을 채택해야 합니다.
         
      2. 완전 탐색을 수행하는 과정을 여러개의 조각으로 나눕니다.
      
      3. 그 중 하나의 조각을 선택해 완전 탐색의 일부를 만들고, 완전탐색의 나머지는 재귀 호출을 통해 완성합니다.  
      
         (이전에 나온 4중 for 문에서 1개만 재귀함수에서 수행하고, 나머지는 재귀호출을 했습니다.)
      
      4. 더 이상 진행할 수 없는 경우를 파악하여 기저 사례를 꼭 처리합니다.
    
* 이론적 배경: 재귀 호출과 부분 문제
  * 재귀 호출을 공부하면서 짚고 넘어가야할 개념
    * 문제와 부분문제 (problem & subproblem)
  * 위 개념은 다음에 배울 동적계획법이나 분할정복에서도 사용되므로 중요합니다.
  * 먼저 문제의 정의란 무엇일까요?
    * 아래에 2개의 문제가 있습니다.
      * 문제 #1 : 주어진 자연수 수열을 정렬
      * 문제 #2 : {16, 7, 9, 1, 31} 을 정렬
    * 얼핏 보면 비슷하지만, 큰 차이가 있습니다.
      * 재귀함수에서는 자료의 조합이 정말 중요하다
        심지어 {1,2,3} 을 정렬하는 것과 {3,2,1}을 정렬하는 문제도 서로 다릅니다.
      * 따라서, 위의 문제 2개는 엄밀히 다른 문제이고, 전자는 범위가 없으므로 문제의 정의라고 보기도 어렵습니다.
  * 이제, 문제와 부분문제의 차이점을 통해 이해하고 조각도 찾아볼 수 있습니다.
    * 보글게임의 완전탐색 과정 (즉, **조각**) 을 보면 아래와 같습니다.
      1. 현재 위치 (y, x) 에서 단어의 첫 글자가 있는가?
      2. 상단 (y-1, x) 에서 시작해서, 단어의 나머지 글자들을 찾을 수 있는가?
      3. 좌상단 (y-1, x-1) 에서 시작해서, 단어의 나머지 글자들을 찾을 수 있는가?
      4. ...
      5. ...
    * 최종적으로 총 9개의 **조각**이 나오겠지만 사실 2~9번은 1번으로 부터 파생된 것입니다.
    * 이 때, 1번은 문제라고 하고, 2~9 은 부분문제가 됩니다.

## 6.3 문제: 소풍 (난이도: 하)

* 문제
  * 유치원에서 소풍을 갑니다.
  * 선생님은 2명씩 짝을 지어주려 합니다.
  * 친구가 아닌 아이들을 짝이 되면 싸우기 때문에 떨어트려야 합니다.
  * 일부만 달라도 다른 방법이라고 봅니다. 따라서 아래 2가지는 다른 방법입니다.
    * #1 - (태연, 제시카), (써니, 티파니), (효연, 유리)
    * #2 - (태연, 제시카), (써니, 유리), (효연, 티파니)
* 시간 & 메모리 제한
  
  * 1초 내 실행, 64MB 이하의 메모리
* 입력
  * 첫 줄에는 테스트 케이스의 수 C (C<=50)
  * 각 테스트 케이스
    * 첫번째 줄 : 학생의 수 n (2 <= n <= 10) , 친구 쌍의 수 m (0 <= m <= n(n-1) / 2)
    * 두번째 줄 : 친구 쌍 
* 출력
  
  * 각 테스트 케이스마다 모든 학생을 친구끼리만 짝지어줄 수 있는 방법의 수를 출력
* 예제 입력

  ```shell
  3
  2 1
  0 1
  4 6
  0 1 1 2 2 3 3 0 0 2 1 3
  6 10
  0 1 0 2 1 2 1 3 1 4 2 3 2 4 3 4 3 5 4 5
  ```
* 예제 출력
  ```shell
  1
  3
  4
  ```
* 예제 입출력 설명
  * 첫 번째 테스트케이스
    * (2 1)은 학생이 2명이고 짝이 1개 이므로 답도 1개
  * 두 번째 테스트케이스
    * (4 6)은 학생이 4명이고 6개 짝이므로 모두 친구라는 의미가 됨 (4C2 = 총 6개)
    * 4명을 A,B,C,D라고 할 때, 최종적으로 아래와 같은 3가지 방법이 가능함을 알 수 있습니다
      * (A, B) (C, D)
      * (B, D) (A, C)
      * (C, A) (A, D)

## 6.4 풀이: 소풍

* 완전 탐색
  * 역시 완전 탐색이 어울리는 문제이며 재귀 호출을 이용해 코드를 작성해 보겠습니다.
  * 조각 정하기
    * 2명씩 짝을 짓는 문제이니 전체 학생 n에 대해 n/2 개의 조각이 있다고 합시다.
    * 그리고 한 조각에서는 2명을 짝지어주는 것을 목표로 합시다.
    * 그럼 재귀함수는 주어진 학생들 중에서 계속해서 2명을 짝지어주는 것이 됩니다.
* 1차 코드 (코드 6.4))
  ```c++
  // 전체 학생의 수
  int n;
  // 친구배열
  //   0 1 2 3 ... 
  // 0 x o x o
  // 1 o x x x
  // 2 x x x o
  bool areFriends[10][10];
  
  // taken[i] = i번째 학생이 짝을 이미 찾았으면 true, 아니면 false
  int countParings(bool taken[10]) {
  	// 기저사례: 모든 학생이 짝을 찾았으면 가능한 1가지 경우를 찾았다고 상위에 알려준다
  	// taken[i] 가 모두 true 이므로 짝이 없는 친구가 없는 것임
  	bool finished = true;
  	for(int i =0; i<n; ++i)
  		if(!taken[i]) finished = false;
      if(finished)
      	return 1;
    
      // ret 에 주목해보자
      // 이 함수는 가능한 경우의 수를 모두 찾는 것이다, 따라서 ret을 계속 더해가는 구조이다
      // 만약 친구들을 모두 검색했는데, 그런 경우를 못 찾으면 ret=0 을 반환하므로
      // 해당 경우는 짝지을 수 있는 방법이 없는 것이다, 즉 집계되지 않는다
  	int ret=0;
      // 서로 친구인 두 학생을 찾아 짝을 지어 준다
      for(int i=0; i<n; ++i) {
          for(int j=0; j<n; ++j) {
              // i, j 가 친구가 없는데, 둘이 친구이면
              if(!taken[i] && !taken[j] && areFriends[i][j]) {
                  taken[i] = taken[j] = true;
                  ret += countPairings(taken);
                  taken[i] = taken[j] = false;
              }
          }
      }
      return ret;
  }
  ```
  * 소스코드 이해하기 (그림)
  ![](images/3-1.jpg)
  * 근데 실행해보면, 답이 1 3 4 로 나오지 않습니다.
  * 위 코드의 문제점?
    * 중복으로 세는 것이 발생
    * (0 1) 과 (1 0) 을 별개로 취급함
    * 이러한 문제는 매우 자주 발생하기 때문에 유의해야 합니다.
  * 해결법
    * 빠른 번호부터 찾는 것으로 순서를 강제합니다.
    * 다음에는 남아있는 학생들중에서 번호가 빠른 아이를 또 찾아 주도록 합니다.
    * 그러면 (0 1) 은 찾게 되지만, (1 0) 과 같은 역순은 발생할 수 없습니다.
* 2차 코드 (코드 6.5)
  ```c++
  int n;
  bool areFriends[10][10];
  
  // taken[i] = i번째 학생이 짝을 이미 찾았으면 true, 아니면 false
  int countParings(bool taken[10]) {
      // 남은 학생들 중 가장 번호가 빠른 학생을 찾는다
      int firstFree = -1;
      for(int i=0; i <n ++i) {
          if(!taken[i]) {
              firstFree = i;
              break;
          }
      }
      
      // 기저사례: 모든 학생이 짝을 찾았으면 가능한 1가지 경우를 찾았다고 상위에 알려준다
      // taken[i] 가 모두 true 이므로 짝이 없는 친구가 없는 것임
      if(firstFree == -1)
          return 1;
      
      int ret = 0;
      // 이 학생과 짝지을 학생을 결정한다
      // firstFree + 1 이 핵심이며 바로 다음순서 학생부터 검색시작함을 의미한다
      for(int pairWith = firstFree+1; pairWith <n; ++pariWith) {
          if(!taken[pairWith] && areFriends[firstFree][pairWith]) {
              taken[firstFree] = taken[pairWith] = true;
              ret += countPairings(taken);
              taken[firstFree] = taken[pairWith] = false;
          }
      }
      return ret;
  }
  ```
  * 소스코드 이해하기 (그림)
  ![](images/3-2.jpg)
  * 위 코드에서 답으로 가능한 최대개수
    * 학생 수 10명이 서로 모두 친구인 경우
    * 9 x 7 x 5 x 3 x 1 = 945
      * 첫번째 학생은 9개의 선택지 - 2명 짝지어짐
      * 세번째 학생은 7개의 선택지 - 4명 짝지어짐
      * ...
* 재귀함수를 구현하고자 할 때, 3가지를 잘 생각해보겠습니다.
  * 조각으로 할 것
  * 반환할 것 (boolean 인지?  int 인지?)
  * 함수간에 공유할 것 (파라미터)

## 6.5 문제: 게임판 덮기 (난이도: 하)

* 문제
  * H x W 크기의 격자무늬 게임판이 있습니다.
  * 각 칸은 검은색 혹은 흰색입니다.
  * 흰 칸을 세가지 칸을 차지하는 L 자 모양 블럭으로 채우려고 합니다.
  * 테트리스처럼 회전할 수는 있지만, 검은칸이나 이미 덮은 흰칸을 채우면 안됩니다.
  * 모든 흰 칸을 채우는 방법의 수는 몇 개일까요?
  
* 시간 & 메모리 제한
  
  * 2초안에 실행되어야 하고, 64MB 이하의 메모리만 사용  
  
* 예제  
  
  ![](images/4-1.jpg)
  
* 입력
  * 첫 줄 : 테스트케이스 수 C (C <= 30)
  * 각 테스트케이스
    * 첫번째 줄 : H , W (1 <= H, W <= 20)
    * 두번째 줄 : 게임판의 모양 # (검은칸)  / . (흰칸)
  
* 출력
  
  * 한 줄에 하나씩 흰 칸을 모두 덮는 방법의 수를 출력하라
  
* 예제 입력

  ```shell
  3
  3 7
  #.....#
  #.....#
  ##...##
  3 7
  #.....#
  #.....#
  ##..###
  8 10
  ##########
  #........#
  #........#
  #........#
  #........#
  #........#
  #........#
  ##########
  ```

* 예제 출력

  ```shell
  0
  2
  1514
  ```
  
* 예제 설명
  * 첫번째 예제 : 빈칸이 13개 이므로 L (3칸짜리) 로 다 채울 수 없습니다.
  
  * 두번째 예제 : 아래와 같이 2가지 방법으로 덮을 수 있습니다.  
  
    ![](images/4-2.jpg)

## 6.6 풀이: 게임판 덮기

* 문제가 방법의 수를 찾는 것이므로 무식하게 풀기(완전탐색) 를 이용해 풀 수 있습니다
* 아래와 같이 법칙을 찾는다
  * 흰 칸의 수가 3의 배수가 아니면 무조건 실패다
  * 3의 배수가 아니면 아래의 순서로 진행한다
    * 빈칸 / 3 = N 을 구한다, N은 L자 블록의 개수가 된다
    * 여기서 조각은 한 블럭을 놓는 것을 계산하는 것이 된다
    * 따라서 재귀함수는 한 블록을 내려놓는 것을 기본으로 하고 나머지는 재귀함수를 호출해서 해결한다

### 중복으로 세는 문제

* 문제에는 블록을 어디에 놓든 (어떤 순서로 놓든) 제한이 없습니다.
* 근데, 그렇게 되면 재귀함수에서 중복되는 부분을 피할 수 없습니다.
  (완전탐색을 하다보면 시작위치에 따라서 중복되는 경우가 발생하기 때문에)
* 따라서 시작위치를 강제화 합니다.
* 중복을 제거할 때 조금 다른 점은 아래와 같습니다.
  * 소풍문제 : 다음으로 큰 숫자를 지정함을 통해 불필요한 재귀함수를 호출하지 않음
  * 게임판덮기 문제 : 블록 놓는 순서를 강제화해서 이미 찾은 것은 아예 재귀함수를 호출하지 않음
* 2장 - 문제해결 과정 을 remind 해보면
  * 비슷한 유형 떠올려보기
  * 단순하세 시작할 수 있을까?
  * 손으로 해보기
  * 단순화하기
  * 그림 그려보기
  * 수식화 해보기
  * 분해해보기
  * 뒤에서부터 생각하기
  * **순서를 강제로 만들기**
  * 정규화된 답을 찾기
* 순서를 강제로 만들기를 생각하면서, 왼쪽 위에서 부터 차례대로 블럭을 채운다고 해보겠습니다.
  * 어떤 시작점에서 보면, 왼쪽과 상단은 모두 채워져 있다는 전제가 생깁니다.
  * 그럼 해당 시작점에서 L 블럭을 놓을 수 있는 경우의 수는 4개입니다.

### 답의 수의 상한

* 최대크기인 테스트케이스 3번의 경우 빈칸이 48개 이므로 블럭은 16개가 가능합니다.
* 그럼 가능한 답의 수 = 4^16 = 4,294,967,296 이 되어야 합니다. (한 블럭당 4가지 경우가 가능하므로)
* 이것은 주먹구구 방법을 넘어선다, 그러나 실제로는 그렇게 값이 크지 않음을 직관적으로 알 수 있습니다.
* 예를 들어,
  * 빈칸이 6칸이 있는 경우, 블럭은 2개
  
  * 가능한 답의 수 = 4^2 = 16가지 방법이 나와야 하는데, 실제로는 2가지 밖에 없습니다.  
  
    ![](images/4-3.jpg)

### 구현

```c++
// 주어진 칸을 덮을 수 있는 4가지 방법
// 블록을 구성하는 세 칸의 상대적 위치 (dy, dx) 의 목록
const int coverType[4][3][2] = {
    { {0, 0}, {1, 0}, {0, 1} },  // 그림에서 블럭 b
    { {0, 0}, {0, 1}, {1, 1} },  // 그림에서 블럭 c
    { {0, 0}, {1, 0}, {1, 1} },	 // 그림에서 블럭 d
    { {0, 0}, {1, 0}, {1,-1} }   // 그림에서 블럭 e
};

// set 함수 : board의 (y, x)를 type 방법 덮거나, 덮었던 블록을 없앤다
// delta = 1 이면 덮고, delta = -1 이면 덮었던 블록을 없앤다
// 만약 블록이 게임판 밖으로 나가거나, 서로 곂치거나, 검은 칸을 덮을 때는 false를 리턴한다
bool set(vector<vector<int>>& board, int y, int x, int type, int delta) {   
    
    // 왜 return false, return true를 바로 하지 않고
    // bool ok 와 같이 변수를 선언해서 진행할까?
    // 만약 L자모양이 사용하는 3개지 좌표 중에 1군데만 바꾸고 빠져나가면
    // 남은 칸은 1,0,-1 의 범위를 넘어설수도 있다
    // 그렇게 되면 어떤 좌표는 영원히 덮이지 않거나 또는 영원히 덮여 있을수도 있다
    bool ok = true;
    
    // 각 블럭을 놓을 수 있는 점 3개가 사용가능한지 확인
    for(int i=0; i<3; ++i) {
        const int ny = y + coverType[type][i][0];
        const int nx = x + coverType[type][i][1];        
        // 블록이 게임판 밖으로 나간 경우임
        if(ny < 0 || ny >= board.size() || nx < 0 || nx >= board[0].size())
            ok = false;
        // 검은칸이거나 이미 덮인 칸임, += 를 통해 대입하고 있다
        // 대입이 덮거나 치우는 행위를 의미한다
        else if((board[ny][nx] += delta) > 1)
            ok = false;
    }
    return ok;
}

// cover(재귀함수) : board의 모든 빈 칸을 덮을 수 있는 방법의 수를 반환한다
// board[i][j] = 1 이면, 이미 덮인 칸 혹은 검은 칸
// board[i][j] = 0 이면, 아직 덮이지 않은 흰 칸
int cover(vector<vector<int>>& board) {
    // 아직 채우지 못한 칸 중 가장 윗줄 왼쪽에 있는 칸을 찾는다
    int y = -1, x = -1;
    for(int i = 0; i < board.size(); ++i) {
        for(int j = 0; j < board[i].size(); ++j) {
            if(board[i][j] == 0) {
                y = i;
                x = j;
                break;
            }
        }
        // 찾았으면 for문을 빠져나오고 못 찾았으면 계속 찾는다
        if(y != -1)
            break;
    }
    
    // 기저사례 : 모든 칸을 채웠으면 1을 반환한다 (빈 칸을 못 찾았으므로)
    if(y == -1)
        return 1;
    
    int ret = 0;
    for(int type = 0; type < 4; ++type) {
        // 만약 board[y][x]를 type 형태로 덮을 수 있으면 재귀 호출한다
        if(set(board, y, x, type, 1))
            ret += cover(board);
       	// 덮었던 블록을 치운다
        // 블록을 덮어두면 다음 경우를 찾을 때, 진행이 불가능하므롤
        // ret 은 이미 +1 되어 위로 전달될 것이기 때문에 문제 없다
        set(board, y, x type, -1);
    }
    return ret;
}
```
* 소스코드 이해하기

  ![](images/4-4.jpg)

## 6.7 최적화 문제

* 최적화 문제란 무엇일까요?
  * 지금까지는 여러개의 답을 찾아보는 문제를 다뤘습니다. (가능한 경우의 수 찾기 or 가능한지 알아보기 등)
  * 최적화 문제(Optimization Problem)는 여러개의 답 중에 가장 좋은 답을 찾아내야 하는 조금 다른 문제입니다.
  * 예를 들어
    * "n개의 원소 중에서 r개를 순서 없이 골라내는 방법의 수를 구하라" 는 최적화 문제일까요?
    * "n개의 사과 중에서 r개를 골랐을 때, 무게의 합을 최대인 것을 구하라" 는 최적화 문제일까요?
  * 이 책에서는 최적화 문제를 푸는 여러가지 방법을 다루고 있으며, 가장 기초적인 것은 역시 **완전탐색**을 이용하는 것입니다.
  * 왜냐하면 가능한 방법을 다 찾아보면 그 중에서 제일 좋은 답을 찾아내는 것도 가능하기 때문입니다.
* 예제: 여행하는 외판원 문제 (TSP)
  * TSP(Traveling Salesman Probelm)은 매우 유명한 문제입니다.
  * 어떤 나라에 n (2<=n<=10) 개의 도시가 있다고 가정합시다.
  * 한 영업사원이 한 도시에서 출발해 모든 도시들을 한 번씩 방문한 뒤 처음 도시로 돌아오려 합니다.
  * 이 때, 가장 짧은 거리로 방문하는 방법은 어떻게 찾을 수 있을까요?
* 무식하게 풀 수 있을까요?
  * 일단 n 개의 도시가 있다고 가정하면 (n-1)! 입니다, O(N!)
  
  * 10개의 도시를 가정했기 때문에 9! = 362,880 입니다, 해결가능합니다.
  
  * 그러나 도시가 14개만 되도 13! = 6,227,020,800 , 60억개 이므로 주먹구구 법칙을 토대로 실패할 가능성이 큽니다.  
    
    ![](images/5-1.jpg)
* 재귀호출을 통한 답안 생성 (코드 6.7)
  ```c++
  int n;  // 도시의 수
  double dist[MAX][MIN];  // 두 도시 간의 거리를 저장하는 배열
  
  // path : 지금까지 만든 경로
  // visited : 각 도시의 방문 여부
  // currentLength: 지금까지 만든 경로의 길이
  // 나머지 도시들을 모두 방문하는 경로들 중 가장 짧은 것의 길이를 반환한다
  double shortestPath(vector<int>& path, vector<bool>& visited, double currentLength) {
      // 기저사례: 모든 도시를 다 방문했을 떄는 시작 도시로 돌아가고 종료한다
      if(path.size == n)
          return currentLength + dist[path[0]][path.back()];
      
      double ret = INF;	// 매우 큰 값으로 초기화 (확인안된 경로는 거리가 무한대라는 의미)
      // 다음 방문할 도시를 전부 시도해 본다
      for(int next = 0; next < n; ++next) {
          if(visited[next])
              continue;
          
          int here = path.back();
          path.push_back(next);
          visited[next] = true;
          
          // 나머지 경로를 재귀 호출을 통해 완성하고 가장 짧은 경로의 길이를 얻는다
          double cand = shortestPath(path, visited, currentLength + dist[here][next]);
          ret = min(ret, cand);
          visited[next] = flase;
          path.pop_back();
      }
      return ret;
  }
  ```

## 6.8 문제: 시계 맞추기 (난이도: 중)

* 문제
  * 아래 그림처럼 4 x 4 형태의 16개의 시계가 있습니다.  
    
    ![](images/6-1.jpg)
    
  * 각각은 12시 / 3시 / 6시 / 9시 중 하나를 가리킵니다.
  
  * 시간을 바꾸는 방법은 스위치를 누르는 것입니다.
    * 스위치는 각 시계를 3시간씩 앞으로 움직이게 합니다. (12시 > 3시로 , 3시 > 6시로 ...)
    
    * 1개의 스위치는1개 이상의 시계와 연결되어 있습니다.
    
    * 예를 들면 아래와 같으며, 시계 번호는 최상단왼쪽의 0부터 시작해서 오른쪽으로 갈수록 1씩 증가됩니다.  
      
      ![](images/6-2.jpg)
    
  * 모든 시계가 12시를 가리키도록 하는데 필요한 스위치를 누르는 최소 회수는 어떻게 될까요?
* 시간 및 메모리 제한
  
  * 10초 이내, 64MB 이하 메모리만 사용
* 입력
  * 첫 줄 : 테스트 케이스 개수 C (C<= 30)
  * 각 테스트 케이스 : 16개 시계가 현재 가리키는 시간
* 출력
  * 각 테스트 케이스당 정수 하나를 한 줄에 출력한다
  * 이 정수들은 모든 시계를 12시로 바꾸는데 필요한 최소한의 스위치 누름횟수이다
  * 불가능한 경우 -1 을 출력한다
* 예제입력
  ```shell
  2
  12 6 6  6 6 6 12 12 12 12 12 12 12 12 12 12 
  12 9 3 12 6 6  9  3 12  9 12  9 12 12  6  6 
  ```
* 예제출력
  ```shell
  2
  9
  ```
* 예제 입출력 설명
  * 첫번째 테스트케이스는 8번 스위치를 누르면 해결된다 (예제출력은 2번인데 8번...?)
  * 두번째 테스트케이스는 여러가지 방법이 있지만, 아래와 같이 누르면 9번 만에 됩니다.
    * 스위치 누르는 순서 : 0, 1, 5, 6, 6, 6, 6, 3, 7

## 6.9 풀이: 시계 맞추기

* 문제 변형하기
  * 있는 그대로 풀려면 매우 복잡한 문제입니다.
  * 단순화해보면 어떨까요?
    * 스위치를 누르는 순서는 결과에 영향을 주지 않습니다.
      * 밑에 간단예제에서 이유 확인, 기본적으로는 각 시계는 자기만 독립적으로 돌아가기 때문에 (연쇄반응 X)
    * 따라서 스위치를 몇 번 눌러야 하는지만 신경쓰면 됩니다.
    * 여기까지 알았다고 해도 완전 탐색 알고리즘을 바로 적용하면 조합의 수는 무한하기 때문에 어렵습니다.
      * 왜냐하면 시계를 계속 돌릴 수 있기 때문에 끝이 없습니다.
    * 각 시계는 12시간이 지나면 제 자리로 돌아옵니다.
      * 즉, 어떤 시계와 연결된 스위치를 4번 누르는 것은 제자리이기 때문에 의미가 없습니다.
        (하나도 누르지 않은 것과 같습니다.)
      * 이말은 따라서 **어떤 스위치든 3번 이상 누르는 것은 의미가 없다**가 됩니다.
        (스위치를 누르는 회수 : 0 <= n <= 3)
      * 예제에서는 10개의 스위치가 있으므로 모든 경우의 수는 4^10 = 1,048,576 이 됩니다.
      * 이제, 문제가 주먹구구 방법에 의거해 완전탐색으로 해볼만한 문제임을 알게 되었습니다.
* 완전 탐색 구현하기 (코드 6.8)
  ```c++
  const int INF = 9999, SWITCHES = 10, CLOCKS = 16;
  
  // linked[i][j] = 'x' : i 번 스위치와 j 번 시계가 연결되어 있다
  // linked[i][j] = '.' : i 번 스위치와 j 번 시계는 연결되어 있지 않다
  // CLOCKS+1 은 character 형태이기 때문에 NULL 추가한 것
  const char linked[SWITCHES][CLOCKS+1] = {
  	"xxx.............",
      "...x...x.x.x....",
      "....x.....x...xx",
      "x...xxxx........",
      "......xxx.x.x...",
      "x.x...........xx",
      "...x..........xx",
      "....xx.x......xx",
      ".xxxxx..........",
      "...xxx...x...x.."
  };
  
  // areAligned함수 : 모든 시계가 12시를 카리키고 있는지 확인하는 함수 (구현 생략)
  bool areAligned(const vector<int>& clocks);
  
  // push함수 : swtch 번 스위치를 누르는 함수
  void push(vector<int>& clocks, int swtch) {
      for(int clock = 0; clock < CLOCKS; ++clock) {
          if(linked[swtch][clock] == 'x') {
              clocks[clock] += 3;
              if(clocks[clock] == 15)
                  clocks[clock] = 3;
          }
      }
  }
  
  // solve함수 : 남은 스위치들을 눌러서 clocks를 12시로 맞출 수 있는 최소 횟수를 반환한다
  // clocks: 현재 시계들의 상태
  // swtch : 이번에 누를 스위치의 번호
  // 만약 불가능하다면 INF 이상의 큰 수를 반환한다
  int solve(vector<int>& clocks, int swtch) {
      if(swtch == SWITCHES)
          return areAligned(clocks) ? 0 : INF;
      
      // 이 스위치를 0번 누르는 경우부터 3번 누르는 경우까지를 모두 시도한다
      int ret = INF;
      for(int cnt = 0; cnt <4; ++cnt) {
          ret = min(ret, cnt + solve(clocks, swtch + 1));
          push(clocks, swtch);
      }
      
      // push(clocks, swtch)가 4번 호출되었으니 clocks는 원래와 같은 상태가 된다
      return ret;
  }
  ```
  * 소스코드 이해하기  
  
    ![](images/6-3.jpg)
  
## 6.10 많이 등장하는 완전탐색 유형
### 모든 순열 만들기

* nPr = n! / (n-r)!
* 재귀함수로 구현할 수 있어야 합니다.
* 순열로 완전탐색을 할 때, N이 10을 넘어가는 경우는 일단 위험할 수 있습니다. (주먹구구 법칙을 기반으로)
* 이 때는 다른 방법을 고려해봐야 합니다. 9.11 에서 그러한 방법을 다룹니다.
* C++의 경우, 다른 언어와 다르게 next_permuation() 함수를 제공하기 때문에 순열을 구현할때 조금 유리합니다.
```c++
#include <string>
#include <iostream>
#include <algorithm>

using namespace std;
 
int main()
{
  string s = "abaac";
  sort(s.begin(), s.end());
  
  int cnt = 0;
  
  do {
      cnt++;
  } while(next_permutation(s.begin(), s.end()));
  
  cout << "result: " << cnt << endl;
}
```
* 위 프로그램의 수행결과는 20이 나옵니다. (5P5 / 3! = 5! / 3! = 20)
* 모든 조합 만들기
  * nCr = n! / r!(n-r)!
  * 재귀함수로 구현할 수 있어야 합니다.
